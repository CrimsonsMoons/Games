-- Auto Kill -> TP -> Stomp -> Next Target (loop kill + Y_OFFSET = 1)

local Players           = game:GetService("Players")
local Workspace         = game:GetService("Workspace")
local RunService        = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer   = Players.LocalPlayer
local playersFolder = Workspace:WaitForChild("Players")

-- how high above their torso you appear (studs)
local Y_OFFSET = 1
-- how often to teleport + stomp (seconds)
local TELEPORT_INTERVAL = 0.4

---------------------------------------------------------------------
-- Stomp remote
---------------------------------------------------------------------
local stompRemote = ReplicatedStorage
    :WaitForChild("assets", 9e9)
    :WaitForChild("dh", 9e9)
    :WaitForChild("MainEvent", 9e9)

local stompArgs     = {"Stomp"}
local stompCooldown = false

---------------------------------------------------------------------
-- Kill remote (PrivateServerPanel Kill)
---------------------------------------------------------------------
local killRemote = ReplicatedStorage
    :WaitForChild("assets", 9e9)
    :WaitForChild("dh", 9e9)
    :WaitForChild("RemoteFunction", 9e9)
    :WaitForChild("RemoteFunction", 9e9)

local function killTargetModel(model)
    local plr = Players:FindFirstChild(model.Name)
    if not plr then return end
    if plr == LocalPlayer then return end -- don't kill yourself

    local args = {
        [1] = "PrivateServerPanel",
        [2] = {
            ["Action"] = "Kill",
            ["Arguments"] = {
                ["UserId"] = plr.UserId
            }
        }
    }

    pcall(function()
        killRemote:InvokeServer(unpack(args))
    end)
end

---------------------------------------------------------------------
-- Helpers
---------------------------------------------------------------------
local function getLocalRoot()
    local char = LocalPlayer.Character
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart")
        or char:FindFirstChild("UpperTorso")
        or char:FindFirstChild("Torso")
end

local function getTargetTorso(model)
    return model:FindFirstChild("UpperTorso")
        or model:FindFirstChild("Torso")
        or model:FindFirstChild("HumanoidRootPart")
end

-- pick the next target:
-- any model under workspace.Players, not you, and not marked Stomped
local function getNextTarget()
    for _, m in ipairs(playersFolder:GetChildren()) do
        if m:IsA("Model") and m.Name ~= LocalPlayer.Name then
            local stomped = m:GetAttribute("Stomped")
            if stomped ~= true then
                return m
            end
        end
    end
    return nil
end

---------------------------------------------------------------------
-- Main loop (sequential logic)
---------------------------------------------------------------------
local currentTarget   = nil
local timeSinceLastTP = 0

RunService.Heartbeat:Connect(function(dt)
    -- if we don't have a target, find the next one
    if not currentTarget then
        currentTarget   = getNextTarget()
        timeSinceLastTP = 0
        return
    end

    -- if target vanished from workspace, drop it and try next
    if not currentTarget.Parent then
        currentTarget   = nil
        timeSinceLastTP = 0
        return
    end

    -- if target is now marked stomped, we are done with them -> next
    local stomped = currentTarget:GetAttribute("Stomped")
    if stomped == true then
        currentTarget   = nil
        timeSinceLastTP = 0
        return
    end

    -- every TELEPORT_INTERVAL, TP, run kill, and stomp
    timeSinceLastTP += dt
    if timeSinceLastTP < TELEPORT_INTERVAL then
        return
    end
    timeSinceLastTP = 0

    local root  = getLocalRoot()
    local torso = getTargetTorso(currentTarget)
    if not root or not torso then return end

    -- keep your current rotation, only move position on top of torso
    local oldCF = root.CFrame
    local rX, rY, rZ = oldCF:ToEulerAnglesXYZ()

    local newPos = torso.Position + Vector3.new(0, Y_OFFSET, 0)
    root.CFrame = CFrame.new(newPos) * CFrame.Angles(rX, rY, rZ)

    -- ðŸ”« keep running Kill on the current target (every 0.4s)
    killTargetModel(currentTarget)

    -- ðŸ¥¾ stomp spam with small cooldown while we're on this target
    if not stompCooldown then
        stompCooldown = true
        pcall(function()
            stompRemote:FireServer(unpack(stompArgs))
        end)
        task.delay(0.25, function()
            stompCooldown = false
        end)
    end
end)
